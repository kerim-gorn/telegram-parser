---
alwaysApply: true
---
# ## ПРОЕКТНЫЕ ПРИНЦИПЫ PARSER-LLM

Ты AI-ассистент, помогающий в разработке. Вся работа над этим проектом **ДОЛЖНА** строго следовать этим принципам.

### 1. ТЕХНОЛОГИЧЕСКИЙ СТЕК

* **Язык:** Python 3.11+ (asyncio)
* **Telegram API:** **Telethon** (мы используем **только** эту библиотеку)
* **Оркестрация:** **Docker Compose**
* **Брокер сообщений:** **RabbitMQ**
* **Задачи/Воркеры:** **Celery** (с Celery Beat для планирования)
* **Хранилище сессий:** **Redis**
* **БД для данных:** **PostgreSQL** (с `SQLAlchemy` и `Alembic` для миграций)

### 2. КЛЮЧЕВАЯ АРХИТЕКТУРА

* **Основа:** Паттерн "Продюсер-Очередь-Консьюмер".
* **Хранение Сессий:** **Stateless воркеры**. Сессии (AuthKey) **НИКОГДА** не хранятся в файлах (`*.session`). Мы используем **StringSession** , которые зашифрованы и хранятся в **Redis**.
* **Разделение Воркеров:** У нас два *разных* типа воркеров (сервисов):
  1. **"Исторический Воркер" (Celery Worker):** Эфемерный. Получает задачу из RabbitMQ (н-р, `parse_history(chat_id)`), запускается, парсит историю , сохраняет в БД и "умирает".
  2. **"Real-time Воркер" (Persistent Service):** Постоянно запущенный сервис. Подключается один раз , слушает сотни чатов через `events.NewMessage`  и *немедленно* пушит сообщения в RabbitMQ для обработки.

### 3. ПРАВИЛА КОДА

* **Всегда Async:** Весь I/O-код (Telegram, БД, Redis) должен быть асинхронным (`async/await`).
* **Конфигурация:** Никаких хардкода. Все ключи (API_ID, HASH, пароли БД, ID чатов) должны загружаться из **переменных окружения** (`.env` файл).
* **Типизация:** Использовать строгую типизацию Python (type hints) во всех функциях.
* **Anti-Ban:** Приоритет №1. Все API-вызовы (особенно парсинг истории) **должны** быть обернуты в декоратор `handle_flood_wait`  с `asyncio.sleep`, джиттером и exponential backoff.
* **Модульность:** Разделяй код на логические модули (например, `db`, `telegram_client`, `workers`, `settings`).